#!/bin/bash
# Regular way to build a SonarSource Maven project.
# Requires the environment variables:
# - SONAR_HOST_URL: URL of SonarQube server
# - SONAR_TOKEN: access token to send analysis reports to $SONAR_HOST_URL
# - ARTIFACTORY_URL: repox url
# - ARTIFACTORY_DEPLOY_ACCESS_TOKEN: access to deploy
# shellcheck source=/dev/null

set -euo pipefail

source "$(dirname "$0")"/includes/version_util
source "$(dirname "$0")"/includes/jfrog_utils.sh

: "${ARTIFACTORY_URL?}" "${ARTIFACTORY_DEPLOY_ACCESS_TOKEN?}"

function jfrog_npm_publish() {
  jfrog config remove repox > /dev/null 2>&1 # Do not log if the repox config were not present
  jfrog config add repox --artifactory-url "$ARTIFACTORY_URL" --access-token "$ARTIFACTORY_DEPLOY_ACCESS_TOKEN"
  jfrog npm-config --repo-resolve npm --repo-deploy sonarsource-npm-public-qa

  jfrog npm publish --build-name="$CIRRUS_REPO_NAME" --build-number="$BUILD_NUMBER"
  jfrog rt build-publish "$CIRRUS_REPO_NAME" "$BUILD_NUMBER"
}

PACKAGE_JSON="package.json"

if [[ -z "${ARTIFACTORY_ACCESS_TOKEN:-}" && -z "${ARTIFACTORY_PRIVATE_PASSWORD:-}" ]]; then
  echo "Warning: Set either ARTIFACTORY_ACCESS_TOKEN or ARTIFACTORY_PRIVATE_PASSWORD."
fi

# Fetch all commit history so that SonarQube has exact blame information
# for issue auto-assignment
# This command can fail with "fatal: --unshallow on a complete repository does not make sense"
# if there are not enough commits in the Git repository
# For this reason errors are ignored with "|| true"
git fetch --unshallow || true

# fetch references from github for PR analysis
if [ -n "${GITHUB_BASE_BRANCH}" ]; then
	git fetch origin "${GITHUB_BASE_BRANCH}"
fi

if [ -z "$PIPELINE_ID" ]; then
  PIPELINE_ID=$BUILD_NUMBER
fi

if [ "${GITHUB_BRANCH}" == "master" ] && [ "$PULL_REQUEST" == "false" ]; then
  echo '======= Build, deploy and analyze master'

  git fetch origin "${GITHUB_BRANCH}"

  CURRENT_VERSION=$(jq -r .version "$PACKAGE_JSON")

  . set_npm_build_version "$BUILD_NUMBER"

  check_version_format "$PROJECT_VERSION"

  npm ci
  npm test

  sonar-scanner -X \
        -Dsonar.host.url="$SONAR_HOST_URL" \
        -Dsonar.token="$SONAR_TOKEN" \
        -Dsonar.projectVersion="$CURRENT_VERSION" \
        -Dsonar.analysis.buildNumber="$BUILD_NUMBER" \
        -Dsonar.analysis.pipeline="$PIPELINE_ID" \
        -Dsonar.analysis.sha1="$GIT_SHA1"  \
        -Dsonar.analysis.repository="$GITHUB_REPO" \

  npm run build
  jfrog_npm_publish

elif [[ "${GITHUB_BRANCH}" == "branch-"* ]] && [ "$PULL_REQUEST" == "false" ]; then
  # analyze maintenance branches as long-living branches

  # Fetch all commit history so that SonarQube has exact blame information
  # for issue auto-assignment
  # This command can fail with "fatal: --unshallow on a complete repository does not make sense"
  # if there are not enough commits in the Git repository
  # For this reason errors are ignored with "|| true"
  git fetch --unshallow || true

  git fetch origin "${GITHUB_BRANCH}"

  CURRENT_VERSION=$(jq -r .version "$PACKAGE_JSON")

  if [[ $CURRENT_VERSION =~ "-SNAPSHOT" ]]; then
    echo "======= Found SNAPSHOT version ======="
    # Do not deploy a SNAPSHOT version but the release version related to this build
    . set_npm_build_version "$BUILD_NUMBER"
    check_version_format "$(jq -r .version "$PACKAGE_JSON")"
  else
    echo "======= Found RELEASE version ======="
    echo "======= Deploy $CURRENT_VERSION ======="
    check_version_format "$CURRENT_VERSION"
  fi

  npm ci
  npm test

  sonar-scanner \
      -Dsonar.host.url="$SONAR_HOST_URL" \
      -Dsonar.token="$SONAR_TOKEN" \
      -Dsonar.branch.name="$GITHUB_BRANCH" \
      -Dsonar.analysis.buildNumber="$BUILD_NUMBER" \
      -Dsonar.analysis.pipeline="$PIPELINE_ID" \
      -Dsonar.analysis.sha1="$GIT_SHA1"  \
      -Dsonar.analysis.repository="$GITHUB_REPO" \

  npm run build
  jfrog_npm_publish


elif [ "$PULL_REQUEST" != "false" ]; then
  echo '======= Build and analyze pull request'

  # Do not deploy a SNAPSHOT version but the release version related to this build and PR
  . set_npm_build_version "$BUILD_NUMBER"


  if [ "${DEPLOY_PULL_REQUEST:-}" == "true" ]; then
    echo '======= with deploy'

    check_version_format "$PROJECT_VERSION"

    npm ci
    npm test

    sonar-scanner \
        -Dsonar.host.url="$SONAR_HOST_URL" \
        -Dsonar.token="$SONAR_TOKEN" \
        -Dsonar.analysis.buildNumber="$BUILD_NUMBER" \
        -Dsonar.analysis.pipeline="$PIPELINE_ID" \
        -Dsonar.analysis.sha1="$GIT_SHA1"  \
        -Dsonar.analysis.repository="$GITHUB_REPO" \
        -Dsonar.analysis.prNumber="$PULL_REQUEST" \

    npm run build
    jfrog_npm_publish

  else
    echo '======= no deploy'

    npm ci
    npm test

    sonar-scanner \
        -Dsonar.host.url="$SONAR_HOST_URL" \
        -Dsonar.token="$SONAR_TOKEN" \
        -Dsonar.analysis.buildNumber="$BUILD_NUMBER" \
        -Dsonar.analysis.pipeline="$PIPELINE_ID" \
        -Dsonar.analysis.sha1="$PULL_REQUEST_SHA" \
        -Dsonar.analysis.repository="$GITHUB_REPO" \
        -Dsonar.analysis.prNumber="$PULL_REQUEST" \

    npm run build
  fi

elif [[ "$GITHUB_BRANCH" == "dogfood-on-"* ]] && [ "$PULL_REQUEST" == "false" ]; then
  echo '======= Build dogfood branch'

  CURRENT_VERSION=$(jq -r .version "$PACKAGE_JSON")

  . set_npm_build_version "$BUILD_NUMBER"

  check_version_format "$PROJECT_VERSION"

  npm ci
  npm run build
  jfrog_npm_publish

elif [[ "$GITHUB_BRANCH" == "feature/long/"* ]] && [ "$PULL_REQUEST" == "false" ]; then
  echo '======= Build and analyze long lived feature branch'

  npm ci
  npm test

  sonar-scanner \
    -Dsonar.host.url="$SONAR_HOST_URL" \
    -Dsonar.token="$SONAR_TOKEN" \
    -Dsonar.branch.name="$GITHUB_BRANCH" \
    -Dsonar.analysis.buildNumber="$PULL_REQUEST" \
    -Dsonar.analysis.pipeline="$PIPELINE_ID" \
    -Dsonar.analysis.sha1="$GIT_SHA1"  \
    -Dsonar.analysis.repository="$GITHUB_REPO" \

  npm run build

else
  echo '======= Build, no analysis, no deploy'

  npm ci
  npm test
  npm run build
fi
